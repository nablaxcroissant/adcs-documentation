{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ADCS Documentation The basic goal of any ADCS system is to take in sensor data, do some math on that data to figure out your position, and then use the knowledge of position to control the satellite. flowchart TD A[Sensors] B[Math] C[Attitude] D[Control] A --> B B --> C C --> D Software Overview Magnetic Field Model Hardware Overview","title":"Home"},{"location":"#adcs-documentation","text":"The basic goal of any ADCS system is to take in sensor data, do some math on that data to figure out your position, and then use the knowledge of position to control the satellite. flowchart TD A[Sensors] B[Math] C[Attitude] D[Control] A --> B B --> C C --> D","title":"ADCS Documentation"},{"location":"#software-overview","text":"Magnetic Field Model","title":"Software Overview"},{"location":"#hardware-overview","text":"","title":"Hardware Overview"},{"location":"help/","text":"Welcome to ADCS Documentation hosted by MkDocs For full documentation visit mkdocs.org . Install Go to this site for install . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Help"},{"location":"help/#welcome-to-adcs-documentation-hosted-by-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to ADCS Documentation hosted by MkDocs"},{"location":"help/#install","text":"Go to this site for install .","title":"Install"},{"location":"help/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"help/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"magnetic_field_model/","text":"Magnetic Field Model Owner: @Lundeen Github pull request Outline The satellite knows where it is because it has a GPS. Using GPS coordinates, the satellite can use an internal model of the earth's magnetic field to calculate what the magnetic field vector should be at that point. This can later be compared with magnetometer readings to calculate the attitude of the satellite. Resources Masters thesis by Gie\u00dfelmann IGRF14 coefficients Details Because the magnetic field has no sources in space (no large currents or changing electric fields) it can be described as the gradient of a scalar function, and this scalar function must satisfy a laplace equation. The laplace equation is solved for spherical potentials and it can be shown that solutions to the laplace equation must be in the form of a radial function times a spherical harmonic. The spherical harmonics are simply a sinusoid in the phi(azimuthal) direction and a legendre polynomial in the theta (altitude) direction. Because we know that the magnetic field is the gradient of this potential, we can find its components analytically by taking this gradient. These are shown in the equations below from Gie\u00dfelmann. These equations tell us what we need to calculate: The spherical harmonics (evalutated at our phi, theta). The derivatives of the harmonics to give us the theta term. The harmonic coefficients. These are measured by NOAA and [listed in the resource above. We will store these but not calculate them ourselves. Calculating Legendre Polynomials Wikipedia on associated legendre functions Technically these are not polynomials, but functions because they have non integer powers. The values (calculated at a given theta and phi) are stored in an array as follows: const float P = Pnm[n][m]; // Legendre polynomials const float dP = Pnm[m][n+1] // Derivatives There is a funny little recursion relation that I don't quite understand to generate them. TODO: Ask Lundeen how this works. Results First we need to run the script by modifying main. First add the proper include: #include \"tests/b_field_tests.h\" Then add the test scripts after initalizing slate: test_b_field_reference_points(&slate); test_b_field_mapping(&slate); test_b_field_ecef_conversion(&slate); As you run it you can run the python script in utils: $ python serial_copy.py This script literally just takes the output from the serial usb stream and dumps it all straight into a .txt file. I then processed the file (I deleted the lines that I didn't need in a text editor), and copied the file over to the /igrf folder. I also renamed it to magnetic_data.csv so that it would play well with the scripts we have there. The images below are generated respectively using $ python magnetic_plotter.py $ python igrf_comparison.py Note that the legend on the magnitude is displaying magnitude 1e-7+1. Meaning that the magnitude is well normalized nearly everwhere, allowing for some floating point rounding.","title":"Magnetic Field Model"},{"location":"magnetic_field_model/#magnetic-field-model","text":"Owner: @Lundeen Github pull request","title":"Magnetic Field Model"},{"location":"magnetic_field_model/#outline","text":"The satellite knows where it is because it has a GPS. Using GPS coordinates, the satellite can use an internal model of the earth's magnetic field to calculate what the magnetic field vector should be at that point. This can later be compared with magnetometer readings to calculate the attitude of the satellite.","title":"Outline"},{"location":"magnetic_field_model/#resources","text":"Masters thesis by Gie\u00dfelmann IGRF14 coefficients","title":"Resources"},{"location":"magnetic_field_model/#details","text":"Because the magnetic field has no sources in space (no large currents or changing electric fields) it can be described as the gradient of a scalar function, and this scalar function must satisfy a laplace equation. The laplace equation is solved for spherical potentials and it can be shown that solutions to the laplace equation must be in the form of a radial function times a spherical harmonic. The spherical harmonics are simply a sinusoid in the phi(azimuthal) direction and a legendre polynomial in the theta (altitude) direction. Because we know that the magnetic field is the gradient of this potential, we can find its components analytically by taking this gradient. These are shown in the equations below from Gie\u00dfelmann. These equations tell us what we need to calculate: The spherical harmonics (evalutated at our phi, theta). The derivatives of the harmonics to give us the theta term. The harmonic coefficients. These are measured by NOAA and [listed in the resource above. We will store these but not calculate them ourselves.","title":"Details"},{"location":"magnetic_field_model/#calculating-legendre-polynomials","text":"Wikipedia on associated legendre functions Technically these are not polynomials, but functions because they have non integer powers. The values (calculated at a given theta and phi) are stored in an array as follows: const float P = Pnm[n][m]; // Legendre polynomials const float dP = Pnm[m][n+1] // Derivatives There is a funny little recursion relation that I don't quite understand to generate them. TODO: Ask Lundeen how this works.","title":"Calculating Legendre Polynomials"},{"location":"magnetic_field_model/#results","text":"First we need to run the script by modifying main. First add the proper include: #include \"tests/b_field_tests.h\" Then add the test scripts after initalizing slate: test_b_field_reference_points(&slate); test_b_field_mapping(&slate); test_b_field_ecef_conversion(&slate); As you run it you can run the python script in utils: $ python serial_copy.py This script literally just takes the output from the serial usb stream and dumps it all straight into a .txt file. I then processed the file (I deleted the lines that I didn't need in a text editor), and copied the file over to the /igrf folder. I also renamed it to magnetic_data.csv so that it would play well with the scripts we have there. The images below are generated respectively using $ python magnetic_plotter.py $ python igrf_comparison.py Note that the legend on the magnitude is displaying magnitude 1e-7+1. Meaning that the magnitude is well normalized nearly everwhere, allowing for some floating point rounding.","title":"Results"}]}